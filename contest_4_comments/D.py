def get_k_ordered(x):
    ind = 0
    row = 1
    col = n
    # пока не выйдем за пределы допустимых значений столбцов и строк таблицы умножения
    while row <= n and col > 0:
        # смотрим на каждом шагу, если последний элемент текущей строки в таблице умножения меньше x, значит
        # нужно перейти на следующую строку и искать порядковый номер уже там
        if row * col < x:
            # прибавляем пройденное количество столбцов в текущей строке
            ind += col
            row += 1
            continue
        # если же нашли подходящую строку, значит x где-то в ней
        # начинаем уменьшать значение столбца, пока не дойдем до нужного
        col -= 1
    return ind


n, k = map(int, input().split())
# аналогично предыдущей задаче - бинпоиск по ответу
# думал можно решить тупо формулой, но не смог вывести
left = 0
right = int(2e10)
while right - left > 1:
    mid = (left + right) // 2
    # перебираем ответ на задачу и получаем по нему порядковый номер этого числа в таблице умножения по возрастанию
    # нам нужно чтобы этот номер попал в k, относительно этого сдвигаем границы бинпоиска
    if get_k_ordered(mid) < k:
        left = mid
    else:
        right = mid
print(left)
