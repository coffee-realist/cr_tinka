n, c = map(int, input().split())
lst = []
# представляем каждую задачу в виде события [время появления задачи, время окончания задачи, ее порядковый номер]
for i in range(n):
    start, time = list(map(int, input().split()))
    lst.append([start, start + time, i + 1])
# сортируем задачи по времени их появления и окончания
# сортируем в обратном порядке, чтобы удобно и быстро можно было обрабатывать эти события,
# работая с концом стека (массива), а не с его началом
lst.sort(reverse=True)
# извлекаем самую первую по времени задачу и добавляем ее в ответ
result = c
start, end, ind = lst.pop()
problems = [ind]
# пока стек не пустой
while len(lst):
    # забираем следующую по времени задачу
    current = lst.pop()
    # если она заканчивается раньше предыдущей и мы знаем, что ее начало точно не раньше предыдущей из-за сортировки,
    # то ее временной отрезок будет выгоднее, чем у той задачи, которую мы взяли до этого
    if current[1] < end:
        # значит удаляем последнюю добавленную задачу и вместо нее добавляем текущую
        problems.pop()
        start, end, ind = current
        problems.append(current[-1])
    # если же начало текущей задачи лежит после окончания последней добавленной, значит можем начинать решать эту задачу
    elif current[0] >= end:
        # обновляем последний взятый элемент и добавляем задачу в ответ
        start, end, ind = current
        problems.append(ind)
        result += c
print(result)
print(len(problems))
print(*problems)
