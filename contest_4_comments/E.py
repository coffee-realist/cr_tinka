from math import inf


def get_k(x):
    sectors = 1
    current_sum = 0
    for i in lst:
        # если нашли в массиве элемент больше предполагаемого ответа (максимума), значит надо искать другой ответ
        if i > x:
            # в этом случае наш максимум слишком мал, значит нужно вернуть большое кол-во отрезков,
            # чтобы корректно сдвинулись границы бинпоиска
            return inf
        # если при прибавлении следующего элемента массива мы укладываемся в наш максимум, то добавляем
        if current_sum + i <= x:
            current_sum += i
        else:  # иначе нужно начинать считать следующий отрезок чисел; инкриминируем число отрезков, обновляем сумму
            sectors += 1
            current_sum = i
    return sectors


n, k = map(int, input().split())
lst = list(map(int, input().split()))
# уже задолбал, но опять бинпоиск по ответу, ибо я не знаю как это иначе решить
left = min(lst)
right = int(2e14)
while right - left > 1:
    mid = (left + right) // 2
    # перебираем ответ и смотрим можно ли с таким ответом разбить массив на k отрезков
    # относительно результата сдвигаем границы бинпоиска
    if get_k(mid) <= k:
        right = mid
    else:
        left = mid
# костыль; если один элемент, то он и будет ответом
if n == 1:
    print(left)
else:  # иначе выводим правую границу, в которой лежит ответ найденный бинпоиском
    print(right)
