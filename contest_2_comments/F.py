# не заходит на питоне, только на c++ и то надо с бубном потанцевать
# но алгоритм там такой же, как и тут

from collections import deque

n = int(input())
# используем двойную очередь, которая умеет добавлять и удалять в конец и начало за O(1)
# а это по сути всё, что требуется от задачи
# но ещё нужно уметь находить элемент по индексу тоже за O(1), циклами такое не зайдет по времени
d = deque()
# здесь как раз и будем хранить индексы по элементам, так как элементы это айдишники и они уникальны
database = [0] * 100002
# текущее количество людей, ушедших из очереди после покупки билета
out = 0
for i in range(n):
    query = input()
    _type = int(query[0])
    if _type == 1:
        _id = int(query.split()[1])
        # по айдишнику присваиваем порядковый номер, то бишь длину дека + добавляем количество ушедших на текущий момент
        # ибо потом придется отнимать ушедших за всё время, а когда добавляем очередного для него количество ушедших 0;
        # поэтому когда потом отнимем текущее кол-во ушедших, то можем на выходе получить отрицательное число,
        # а отличаться от ответа оно будет ровно на количество ушедших на момент добавления того человека в дек
        database[_id] = len(d) + out
        d.append(_id)
    elif _type == 2:
        d.popleft()
        out += 1
    elif _type == 3:
        d.pop()
    elif _type == 4:
        _id = int(query.split()[1])
        print(database[_id] - out)
    elif _type == 5:
        print(d[0])
