n = int(input())
# (-1, т.к. цвета от 0 до 9)
# -1 в конце списка нужно для ещё одного прохода цикла, потому что если в конце после всех разрушений
# остался ряд, который подлежит уничтожению, то в иф с разрушением он никогда не зайдет,
# только кол-во элементов посчитается
# по сути это мини костылек
lst = list(map(int, input().split())) + [-1]
stack = []
# сколько сейчас подряд
streak = 1
# ответ
destroyed = 0
for i in lst:
    # если стек пуст, просто добавляем
    if len(stack) == 0:
        stack.append(i)
        continue
    # если текущий равен последнему элементу стека, то прибавляем счётчик одинаковых подряд идущих
    if i == stack[-1]:
        streak += 1
    elif streak > 2:
        # прибавляем к ответу кол-во идущих подряд
        destroyed += streak
        # смотрим что нужно удалить из стека и удаляем
        to_destroy = stack.pop()
        while len(stack) and stack[-1] == to_destroy:
            stack.pop()
        # если в стеке от двух элементов, то проверяем последние два равны или нет, чтобы обновить стрик
        if len(stack) > 1 and stack[-1] == stack[-2]:
            streak = 2
        # в противном случае стрик всегда равен одному, т.к. 1 идущий подряд и стек сейчас точно не пустой
        else:
            streak = 1
        # при этом если текущий элемент, который хотим добавить равен следующему, то увеличиваем стрик
        if len(stack) and i == stack[-1]:
            streak += 1
        # иначе нужно его опять скинуть в единицу, т.к. до этого могли переприсвоить 2ку
        else:
            streak = 1
    else:
        streak = 1
    stack.append(i)
print(destroyed)
