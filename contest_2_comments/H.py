# если коротко, то задачка полный пиздец, в целом алгоритм такой:
# в стек добавляем по 2 элемента: первый - текущий элемент (минимум на текущем отрезке), второй - текущая сумма
# при этом если новый элемент cur больше последнего в стеке, то просто добавляем в стек [cur, cur]
# а вот если попался элемент меньше либо равный последнему, то начинается веселье
# в теории нужно извлекать из стека элементы до тех пор, пока последний элемент в стеке меньше текущего попавшегося
# при этом у извлеченного элемента [x, s] считать x * s (ответ на задачу) и если произведение больше максимума,
# который храним в отдельной переменной, то обновляем этот максимум, а потом сумму s из извлеченного элемента стека
# прибавляем к сумме текущего последнего элемента стека;
# если мы не сделали этого прибавления, но извлекли элемент из стека, то эту сумму нужно прибавить
# к текущему элементу cur и добавить в стек [cur, s + cur], а если не сделали и не извлекли,
# то извлечь сумму в последнем элементе стека ss и добавить в стек [cur, ss + cur], а потом пересчитать
# максимум для добавленного элемента
# на этом заканчивается первый for
# потом если в стеке ещё остались элементы, то мы пересчитываем максимум относительно верхушки стека,
# аналогично если получился больше, то обновляем его, дальше извлекаем верхушку стека и сумму ss из нее прибавляем
# к текущей верхушке стека; так делаем пока стек не окажется пустым

# хрен его знает насколько это текстовое объяснение понятное и насколько я адекватно реализовал этот алгоритм,
# но что мне подсказывает, что можно было обойтись и без этой кучи ифов, флагов и прочих костылей, которые я сделал
# более понятно если и смогу объяснить, то только устно и на конкретном примере

n = int(input())
lst = list(map(int, input().split()))
stack = []
max_sum = 0
for current in lst:
    if len(stack) == 0 or current > stack[-1][0]:
        stack.append([current, current])
    else:
        in_while = False
        flag = False
        while len(stack) and current < stack[-1][0]:
            flag = False
            in_while = True
            last = stack.pop()
            current_sum = last[0] * last[-1]
            if current_sum > max_sum:
                max_sum = current_sum
            if len(stack) and current < stack[-1][0]:
                stack[-1][-1] += last[-1]
                flag = True
        if not flag:
            if in_while:
                stack.append([current, last[-1] + current])
            else:
                to_add = stack.pop(-1)[-1]
                stack.append([current, to_add + current])
                curr = stack[-1][0] * stack[-1][-1]
                if curr > max_sum:
                    max_sum = curr
while len(stack):
    current_sum = -1
    while current_sum <= max_sum and len(stack):
        last = stack.pop()
        current_sum = last[0] * last[-1]
        if len(stack):
            stack[-1][-1] += last[-1]
    if current_sum > max_sum:
        max_sum = current_sum
print(max_sum)
